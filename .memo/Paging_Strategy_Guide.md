# 페이징 구현 방식 통일을 위한 팀 가이드

## 1. 왜 `Pageable` 방식을 선택했는가? (핵심 메시지)

우리 팀이 페이징 구현 방식으로 Spring Data JPA의 `Pageable`을 선택한 이유는 다음과 같습니다.

- **"한 번 만들고, 계속 재사용해요!" (높은 생산성)**

  > 공용 DTO를 한 번만 잘 설계해두면, 상품, 댓글, 검색 등 모든 페이징 기능에서 코드를 재사용하여 개발 속도를 높일 수 있습니다.

- **"서비스는 서비스답게!" (깔끔한 코드 구조)**

  > 복잡한 페이지 계산 로직을 DTO와 JPA에 위임함으로써, 서비스 계층은 순수한 비즈니스 로직에만 집중하여 코드의 가독성과 유지보수성을 향상시킬 수 있습니다.

- **"스프링에게 맡기세요!" (프레임워크 활용 극대화)**
  > 스프링 부트의 핵심 철학은 '자동화'와 '생산성'입니다. `Pageable`은 이 철학이 가장 잘 반영된 기능 중 하나로, 이를 활용하는 것이 프로젝트를 가장 효율적으로 개발하는 방법입니다.

---

## 2. 방식 변경에 따른 팀원별 작업 변화 비교

새로운 `Pageable` 방식을 도입함으로써, 기존 방식 대비 우리 팀원들의 작업이 어떻게 변하는지 각자의 입장에서 설명합니다.

### **To. 주현 & 찬우 (상품 엔티티, 관리자 페이지 담당)**

- **[요약]** 찬우님은 더 이상 페이징 로직을 복사할 필요 없이, 잘 만들어진 서비스를 호출만 하면 됩니다. 주현님은 DB 구조 설계에 더 집중할 수 있습니다.
- **(편해지는 점)** **찬우님**은 페이징 로직을 전혀 신경 쓸 필요 없이, 완성된 `ProductService`의 페이징 메소드를 **그대로 호출해서 사용하기만 하면 됩니다.** 코드 중복이 사라지고 유지보수가 매우 편해집니다.

### **To. 신우 (댓글 엔티티, 코드 병합 담당)**

- **[요약]** 복잡한 계산 로직을 복사할 필요 없이, 이미 만들어진 DTO와 구조를 재사용하여 훨씬 빠르고 안전하게 댓글 페이징을 구현할 수 있습니다.
- **(편해지는 점)** 검증된 구조를 따라가기만 하면 되므로, **훨씬 빠르고 안정적으로** 새로운 페이징 기능을 완성할 수 있습니다.

### **To. 지성 (프론트엔드, 주문/장바구니 담당)**

- **[요약]** 모든 페이징 API의 응답 구조가 100% 동일해지므로, 하나의 UI 컴포넌트를 만들어 모든 목록 페이지에서 재사용할 수 있어 생산성이 극대화됩니다.
- **(편해지는 점)** 앞으로 만들어질 **모든 페이징 API의 응답 구조가 100% 동일**합니다. 따라서 하나의 페이지네이션 UI 컴포넌트를 만들어두면, 어떤 목록 페이지에서든 **그대로 재사용**할 수 있습니다.

---

## 3. 그래서 우리는 앞으로 어떻게 해야 할까? (팀원별 Action Item)

제가 `PageRequestDTO`와 `PageResponseDTO`라는 공용 부품을 만든 이유는, 팀원 여러분들이 페이징 기능을 더 쉽고 일관되게 구현할 수 있도록 돕기 위함입니다. 앞으로 각자 페이징 관련 작업을 하실 때 아래 가이드를 참고해주세요.

### **To. 주현 & 찬우 (상품 / 관리자 페이지)**

- **핵심 키워드:** `QueryDSL`, `RepositoryCustom`
- **앞으로 수정/생성할 파일:**
  1.  `repository/search/ProductRepositoryCustom.java` (생성): 상품 검색 조건을 정의할 인터페이스.
  2.  `repository/search/ProductRepositoryCustomImpl.java` (생성): QueryDSL로 실제 검색+페이징 쿼리를 구현할 클래스.
  3.  `service/ProductService.java` (수정): `findAll` 대신 새로 만든 `search` 메소드를 호출하도록 변경.
- **DTO 활용법:**
  - `ProductService`의 목록 조회 메소드 파라미터로 `PageRequestDTO`를 받으세요.
  - 메소드의 최종 반환 값으로 `PageResponseDTO<ProductResponseDto>`를 사용하시면 됩니다.

### **To. 신우 (댓글)**

- **핵심 키워드:** `재사용`, `구조 참고`
- **앞으로 수정/생성할 파일:**
  1.  `repository/search/ReviewRepositoryCustom.java` (생성)
  2.  `repository/search/ReviewRepositoryCustomImpl.java` (생성)
  3.  `service/ReviewService.java` (수정)
- **DTO 활용법:**
  - 상품 페이징에서 사용된 `PageRequestDTO`와 `PageResponseDTO`를 **그대로 가져와서** 사용하시면 됩니다.
  - `PageResponseDTO`의 제네릭 타입만 `<ReviewResponseDto>`로 바꿔주면 모든 것이 동일하게 동작합니다.

### **To. 지성 (프론트엔드)**

- **핵심 키워드:** `API 요청/응답 규격`, `UI 컴포넌트 재사용`
- **참조할 파일:** `dto/PageRequestDTO.java`, `dto/PageResponseDTO.java`
- **DTO 활용법:**
  - **(요청 시)** 백엔드에 목록 데이터를 요청할 때, `axios.get('/products?page=1&size=10')` 와 같이 `PageRequestDTO`의 필드명을 쿼리 파라미터로 사용합니다.
  - **(응답 처리 시)** 서버로부터 받은 `PageResponseDTO`의 `dtoList`로 목록을 그리고, `pageNumList`, `prev`, `next` 등의 정보로 페이지네이션 UI를 만듭니다. 이 로직을 하나의 컴포넌트로 만들어두면 모든 페이지에서 재사용할 수 있습니다.


---

### **[2025-07-28] 페이징 공통 모듈 설계 (1단계) - PageRequestDTO 강화**

- **담당자:** (본인 이름)
- **관련 파일:** `com.busanit501.shoppingweb_project.dto.PageRequestDTO.java`

#### **1. 변경 내용**
- 기존 `PageRequestDTO`에 검색 기능을 처리하기 위한 `type`(검색 타입), `keyword`(검색어) 필드를 추가함.
- DTO가 스스로 유효한 검색 요청인지 판단할 수 있는 `hasKeyword()` 헬퍼 메소드를 추가함.

#### **2. 설계 의도 및 배경 (The "Why")**

- **(생각)** "페이징과 검색은 거의 항상 함께 사용되는데, 이 두 요청을 각각 다른 파라미터로 받으면 컨트롤러와 서비스가 너무 복잡해진다. 관련된 데이터와 기능은 하나의 객체로 묶어 관리하는 것이 **'높은 응집도'**를 가진 좋은 설계다. 따라서, `PageRequestDTO`를 '페이징과 검색'에 대한 모든 요청 정보를 담는 **표준 규격 상자**로 만들기로 결정했다."

- **(생각)** "서비스 로직에서 `if (keyword != null ...)` 같은 코드를 반복하는 것은 좋지 않다. 객체는 스스로의 상태를 책임져야 한다. `hasKeyword()` 메소드를 DTO 내부에 **캡슐화**함으로써, 서비스 계층의 코드를 간결하게 만들고 DTO의 역할을 더 명확히 했다. 이는 **'Tell, Don't Ask'** 원칙을 따른 것이다."

#### **3. 기대 효과 및 팀에 미치는 영향**

- **개발 생산성 향상:**
  - 팀원들은 앞으로 페이징/검색 기능이 필요할 때, 고민 없이 이 `PageRequestDTO`를 사용하기만 하면 된다.
  - 공통 모듈 사용으로 중복 코드가 줄어들고, 전체 개발 속도가 빨라진다.
- **유지보수 용이성:**
  - 페이징/검색 관련 정책이 변경될 경우, 이 DTO와 관련 서비스만 수정하면 되므로 수정 범위가 명확해진다.
- **팀원 간의 원활한 협업:**
  - "검색 기능은 `type`과 `keyword` 파라미터를 사용합니다" 와 같이 명확하고 표준화된 API 규격을 통해 프론트엔드 개발자와의 소통이 원활해진다.

---
