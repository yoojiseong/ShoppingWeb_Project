# PageRequestDTO.java 코드 분석 및 개발 히스토리

## 1. 파일 개요

- **파일명:** `PageRequestDTO.java`
- **역할:** 클라이언트에서 서버로 페이징 요청 시 필요한 정보(페이지 번호, 페이지 크기 등)를 전달하는 데이터 전송 객체(DTO).
- **특징:** 상품, 댓글 등 여러 도메인에서 공통으로 사용할 수 있는 **범용 페이징 요청 DTO**로 설계하여, 프로젝트 전체의 코드 중복을 최소화하고 일관성을 유지함.

---

## 2. 개발자 '상록'의 생각 흐름 (Thinking Process)

### **@ 설계 고민: 반복 작업을 어떻게 줄일까?**

- **상록의 생각:** "앞으로 만들어야 할 기능이 상품 목록, 댓글 목록, 주문 목록... 전부 페이징이 필요하네. 그때마다 `ProductPageRequestDTO`, `ReviewPageRequestDTO`를 따로 만들 건가? **아니지, 그건 너무 비효율적이야.** 요청하는 정보는 '페이지 번호'와 '개수'로 다 똑같잖아. **이건 무조건 공통으로 쓸 수 있는 범용 DTO로 설계해야겠다.**"

### **@ 안정성 확보: 예외 상황에 대비하자**

- **상록의 생각:** "만약 프론트엔드에서 실수로 페이지 번호나 사이즈 값을 안 보내면 어떻게 되지? `NullPointerException`이 터지면서 서버가 멈출 수도 있겠는데? **이런 예외 상황은 미리 막아야 해.** 요청값이 없더라도 기본적으로 '1페이지', '10개씩' 보여주도록 기본값을 설정해서 안정성을 확보하자."

### **@ 역할 분리: DTO는 DTO답게**

- **상록의 생각:** "서비스 로직에서 JPA의 `Pageable` 객체를 만들 때마다 `page-1`을 하고, `Sort` 객체를 만드는 코드를 반복해서 쓰는 건 너무 지저분해. 이 변환 로직은 '페이징 요청'이라는 맥락에 속한 거니까, **`PageRequestDTO`가 스스로 `Pageable` 객체로 변환하는 기능을 갖도록 하자.** 이게 바로 객체지향의 **캡슐화**지. 서비스는 그냥 `dto.getPageable()`만 호출하면 되니까 훨씬 깔끔해질 거야."

---

## 3. 심층 Q&A: 왜 `Pageable`을 사용하는가? (다른 방식과 비교)

### Q. `Pageable` 방식이 너무 생소한데, 예전처럼 `LIMIT`, `OFFSET`을 직접 계산하면 안 되나요?

**A.** 좋은 질문입니다. 두 방식의 실제 코드를 비교해보면, 왜 `Pageable` 방식이 현대 스프링 개발의 표준이 되었는지 명확히 알 수 있습니다.

#### **시나리오: 전통 방식으로 페이징을 구현했을 때 '상록'이 겪는 고통**

- **상록의 생각:** "자, 상품 목록 페이징을 만들어볼까. 먼저 서비스에서 `offset`을 계산하고... `(page-1) * size`... 그리고 리포지토리에서 `LIMIT`, `OFFSET`으로 목록을 가져오고... 아, 맞다. 전체 페이지 수를 알려면 `count` 쿼리도 따로 날려야 하네. DB를 두 번이나 호출해야 하잖아. 그리고 이 계산 로직을 나중에 댓글 페이징 만들 때 또 복사해서 붙여넣어야 한다고? **이건 아니다. 유지보수 지옥이 눈에 선하다.**"

#### **`Pageable` 방식으로 문제를 해결하는 과정**

- **상록의 생각:** "스프링 Data JPA에 `Pageable`이라는 게 있었지. 이걸 쓰면 어떻게 될까? 서비스에서는 `Pageable` 객체 하나만 만들어서 리포지토리에 넘기면... **와, `Page` 객체 안에 데이터 목록이랑 전체 개수가 한 번에 다 담겨서 오네!** DB 접근도 JPA가 알아서 최적화해주고, `offset` 계산이나 `count` 쿼리 같은 지저분한 코드가 서비스에서 완전히 사라졌어. 이게 바로 프레임워크를 쓰는 이유지!"

| 구분          | **`Pageable` 활용 (현대적 방식)**      | **`LIMIT`/`OFFSET` 직접 계산 (전통 방식)** |
| :------------ | :------------------------------------- | :----------------------------------------- |
| **코드량**    | 압도적으로 간결                        | 서비스 로직이 길고 복잡해짐                |
| **DB 접근**   | JPA가 최적화 (주로 1~2회)              | 최소 2회 (목록 조회 + 개수 조회)           |
| **역할 분리** | 명확 (계산은 JPA, DTO / 로직은 서비스) | 불분명 (서비스가 모든 것을 처리)           |
| **재사용성**  | 매우 높음                              | 매우 낮음 (코드 복사/붙여넣기 발생)        |

**결론:** `Pageable` 방식은 단순히 코드를 줄여주는 것을 넘어, **개발자가 비즈니스 로직에만 집중할 수 있도록 복잡한 과정을 추상화**해주는 스프링 Data JPA의 핵심적인 기능입니다. 따라서 이 표준 방식을 따르는 것이 장기적으로 훨씬 이득입니다.

---

## 4. 커밋 메시지 (보고서 스타일)

```
feat(common): 페이징 요청을 위한 범용 PageRequestDTO 추가

**1. 주요 변경 사항**
- 모든 도메인에서 공통으로 사용할 수 있는 범용 페이징 요청 DTO, `PageRequestDTO`를 추가함.

**2. 변경 목적**
- 기존의 비효율적인 전체 목록 조회 방식에서 벗어나, 페이징 처리를 도입하기 위한 기반을 마련함.
- 향후 구현될 모든 페이징 기능의 요청 규격을 표준화하여, 코드의 중복을 방지하고 프로젝트의 일관성을 확보하고자 함.

**3. 핵심 구현 내용**
- `page`, `size` 필드에 기본값을 설정하여, 요청값 누락 시 발생할 수 있는 예외를 방지함.
- `getPageable()` 메소드를 통해, DTO의 정보를 Spring Data JPA의 `Pageable` 객체로 변환하는 로직을 캡슐화함.
  - 이를 통해 서비스 계층의 코드를 간결하게 유지하고, 페이징 관련 책임을 DTO로 위임함.

**4. 향후 계획**
- 본 DTO를 사용하여 `PageResponseDTO`를 구현하고, 순차적으로 `ProductService` 및 `ProductController`에 페이징 로직을 적용할 예정임.
```
